% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_nonnegative.R, R/all_numbers.R,
%   R/is_nonnegative.R, R/is_number.R, R/is_positive.R
\name{all_nonnegative}
\alias{all_nonnegative}
\alias{all_numbers}
\alias{is_nonnegative}
\alias{is_number}
\alias{is_positive}
\title{Check if \code{x} is numeric}
\usage{
all_nonnegative(x)

all_numbers(x)

is_nonnegative(x)

is_number(x)

is_positive(x)
}
\arguments{
\item{x}{object to test.}
}
\value{
\code{TRUE} or \code{FALSE} indicating if \code{x} is a numeric vector of the
correct length with numbers of the correct sign.
}
\description{
Check if \code{x} is a numeric vector of the correct length with numbers of the
correct sign.
}
\details{
The correct length of \code{x} is larger than zero for \code{all_numbers()}
and one for \code{is_number()}.

\code{all_nonnegative()} and \code{is_nonnegative()} return \code{TRUE} for \code{0}, whereas
\code{is_positive()} returns \code{FALSE} for \code{0}.

\code{all_numbers()} and \code{is_number()} return \code{TRUE} for \code{Inf}, \code{NA_real_},
\code{NA_integer_}, and \code{NaN} because their \code{mode} is \code{numeric}.
}
\section{Wishlist}{

Add argument \code{allow_zero} to optionally allow for zero-length numerics, see
the code of \code{\link[=is_logical]{is_logical()}}.
}

\section{Programming note}{

\code{\link[=is.numeric]{is.numeric()}} tests the \code{\link[=mode]{mode()}} of \code{x}, which is \code{numeric} for
floating-point numbers such as 3.2 and integers such as 3L. In contrast,
\code{class(x) == "numeric"} would test the \code{\link[=class]{class()}} of \code{x} which is \code{numeric}
for floating-point numbers but \code{integer} for integers (see the \verb{Note on names}
in \code{\link[=is.numeric]{is.numeric()}}).

Adding arguments \code{allow_NA} and \code{allow_NaN} to optionally allow \code{NA_real_},
\code{NA_integer_}, or \code{NaN} (which all have \code{mode} \code{numeric}) would solve the
contradiction that using \code{is_number()} currently returns \code{TRUE} for these
values but using them in conditional statements leads to \code{logical(0)} and
thus to an error. However, implementing those arguments is complicated
because \code{is.na(x)} returns \code{TRUE} for \code{NaN} and \code{is.na(x)} and \code{is.nan(x)}
return \code{logical(0)} for zero-length \code{x}, see \code{\link[=are_NA_numeric]{are_NA_numeric()}}.
}

\examples{
is_number(1) # TRUE
is_number(c(1, 2)) # FALSE: incorrect length
all_numbers(c(1, 2)) # TRUE
is_number("a") # FALSE: incorrect type
is_number(numeric(0)) # FALSE: incorrect length
is_number(NA_real_) # TRUE: 'allow_NA' has not been implemented
is_number(NA_character_) # FALSE: incorrect type
is_number(NaN) # TRUE (!)
is_number(Inf) # TRUE
is_nonnegative(3) # TRUE
is_nonnegative(0) # TRUE
all_nonnegative(c(3, 0)) # TRUE
is_positive(3) # TRUE
is_positive(0) # FALSE

}
\seealso{
The vignette about type coercion:
\code{vignette("Type_Coercion", package = "checkinput")}.

Other collections of checks on type and length: 
\code{\link{all_characters}()},
\code{\link{all_names}()},
\code{\link{all_natural}()},
\code{\link{are_NA_numeric}()},
\code{\link{is_logical}()},
\code{\link{is_zerolength}()}
}
\concept{collections of checks on type and length}
