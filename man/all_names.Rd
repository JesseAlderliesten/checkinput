% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_names.R
\name{all_names}
\alias{all_names}
\title{Check if \code{x} only contains syntactically valid names}
\usage{
all_names(x, allow_dupl = FALSE, allow_susp = FALSE, allow_underscores = TRUE)
}
\arguments{
\item{x}{Vector of names to test.}

\item{allow_dupl}{\code{TRUE} or \code{FALSE}: allow duplicate names?}

\item{allow_susp}{\code{TRUE} or \code{FALSE}: allow suspicious names?}

\item{allow_underscores}{\code{TRUE} or \code{FALSE}: allow underscores?}
}
\value{
\code{TRUE} or \code{FALSE} indicating if \code{x} is a character vector that only
contains syntactically valid names and adhere to the restrictions imposed by
the other function arguments.
}
\description{
Check if \code{x} is a character vector that only contains unique, syntactically
valid names that do not suggest they were automatically created or modified.
}
\details{
\link[=make.names]{Syntactically valid names} are names that (1) only consist of
letters, numbers, dots and underscores; (2) start with a letter or with a dot
not followed by a number; (3) are not \link[=Reserved]{reserved words} such as
\link{for} or any of the \link{NA}s. The definition of 'letter' depends on the current
locale, as noted in the section 'Details' in \code{\link[=make.names]{make.names()}}.

Duplicated names, suspicious names, and names containing underscores (\verb{_})
\emph{are} syntactically valid but are \emph{not} allowed if arguments \code{allow_dupl},
\code{allow_susp}, or \code{allow_underscores} are \code{FALSE}, respectively.

This function distinguishes two kinds of suspicious names (see the
\verb{Programming note} for the structure of the regular expressions used to
identify them):
\itemize{
\item Names that might have been created by \code{\link[utils:read.table]{utils::read.csv()}} to name unnamed
columns, either because a particular column was unnamed or because data was
inadvertently present in a supposedly empty (and thus unnamed) column that
was read into \R: column names created by \code{read.csv()} have pattern \code{X},
\code{X.1}, \code{X.2}, \code{...} if \code{header} is \code{TRUE} and pattern \code{V1}, \code{V2}, \code{V3},
\code{...} if \code{header} is \code{FALSE}.
\item Names that might have been modified by
\link[=make.names]{make.names(x, unique = TRUE)} to make duplicated names
unique: a dot and a number (starting at \code{1} for the first duplicate) is
added to duplicated names to make them unique. This is also used by
read.csv().
}

Syntactically invalid names are \emph{not} reported as suspicious names. In
addition, duplicated names are \emph{not} duplicated in warnings emitted by
\code{all_names()}.
}
\section{Programming note}{
 The \link[=regex]{regular expressions} that are used
to identify suspicious names contain the following elements: (1) require a
pattern to start at the beginning of a string: \code{^}; (2) contain an \code{X} or a
\code{V} followed by a literal dot: \verb{X\\\\.} or \verb{V\\\\.}; (3) contain one or more
digits: \verb{[[:digit:]]+}; (4) require a pattern to reach the end of the string:
\code{$}.

These elements are used to identify suspicious names as: (1) column names
that start with an \code{X} followed by a dot and one or more digits until the end
of the string: \verb{^X\\\\.[[:digit:]]+$}; (2) column names that start with a \code{V}
followed by one or more digits until the end of the string: \verb{^V[[:digit:]]+$};
(3) column names that contain a dot followed by one or more digits until the
end of the string: \verb{\\\\.[[:digit:]]+$}. Indicating the end of the string
prevents matching names that start as suspicious names but are not suspicious
because they have non-digit characters appended, e.g. \code{X.2a}.
}

\section{Programming note 2}{
 This implementation is based on legacy-code of
\code{has_colnames()} and \code{has_names()}, with significant changes.
}

\section{To do}{

\itemize{
\item Add an explanation and examples showing the problem of using syntactically
invalid names: see https://stackoverflow.com/questions/54597535/.
\item See https://github.com/r-lib/testthat/blob/main/R/expect-named.R for code
to check against allowed names, with or without ordering.
}
}

\examples{
all_names(x = names(c(a = 1, b = 2))) # TRUE

all_names(x = names(c(a = 1, 2))) # FALSE: empty name.
all_names(x = NULL) # FALSE: NULL

all_names(x = c("a", "b", "a")) # FALSE: duplicated name
all_names(x = c("a", "b", "a"), allow_dupl = TRUE) # TRUE

all_names(x = "X.1") # FALSE: name created by read.csv()
all_names(x = "X.1", allow_susp = TRUE) # TRUE

all_names(x = "e.1") # FALSE: name modified by make.names()
all_names(x = "e.1", allow_susp = TRUE) # TRUE

x_underscores <- c("abc_def", "ghi", "jk_l")
all_names(x = x_underscores, allow_underscores = TRUE) # TRUE
all_names(x = x_underscores, allow_underscores = FALSE) # FALSE: underscores.

}
\seealso{
\code{\link[=all.names]{all.names()}} to find all names in an expression or call; \code{\link[=names]{names()}}
to get or set the names of an object.

Other collections of checks on type and length: 
\code{\link{all_characters}()},
\code{\link{all_nonnegative}()},
\code{\link{are_NA_numeric}()},
\code{\link{is_logical}()},
\code{\link{is_zerolength}()}
}
\concept{collections of checks on type and length}
