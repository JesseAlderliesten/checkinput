% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_natural.R
\name{all_natural}
\alias{all_natural}
\title{Check if \code{x} is natural}
\usage{
all_natural(x, strict = TRUE, allow_NA = FALSE, tol = .Machine$double.eps^0.5)
}
\arguments{
\item{x}{object to test.}

\item{strict}{Exclude zero from the natural numbers?}

\item{allow_NA}{\code{TRUE} or \code{FALSE}: allow \code{NA}s of the correct type in \code{x}?}

\item{tol}{Positive number indicating the maximum difference in value from
natural numbers.}
}
\value{
\code{TRUE} or \code{FALSE} indicating if \code{x} is a vector with only natural
numbers.
}
\description{
Check if \code{x} is a vector with natural numbers, allowing for small numerical
errors.
}
\details{
Natural numbers are the positive integers (\code{1}, \code{2}, \code{3}, etc.). Zero is
considered a natural number if argument \code{strict} is \code{FALSE}. \code{Inf} is \emph{never}
considered to be a natural number in this implementation.

\code{NA_integer_} and \code{NA_real_} are allowed if \code{allow_NA} is \code{TRUE}. Other \link{NA}s
and \link{NaN} are never allowed.

\code{all_natural()} allows for small numeric differences from the intended
natural number, e.g., because of rounding or representation error. As the
\code{Note} at \code{\link{==}} warns, that is \emph{not} the case for \code{x == round(x)} which
tests exact equality. For background see e.g.,
\href{https://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f}{\R FAQ 7.31}.
}
\note{
The code of \code{all_natural()} is partly based on the example \code{is.wholenumber()}
in \code{\link[=is.integer]{is.integer()}}.
}
\section{Programming note}{

\code{\link[=is.integer]{is.integer()}} does \emph{not} check that \code{x} is a natural number (nor if \code{x} is a
whole number) but rather that \code{x} is of \link[=typeof]{type} integer (see the
\code{Note} in \code{\link[=is.integer]{is.integer()}}).

Argument \code{strict} should \emph{not} be renamed to \code{allow_zero} because in other
functions, e.g., \code{\link[=is_logical]{is_logical()}}, \code{allow_zero} is used to allow for
zero-\emph{length} value of \code{x}.
}

\examples{
all_natural(x = c(3, 5 + 1e-10)) # TRUE
# Zero is not considered a natural number if 'strict' is TRUE:
all_natural(x = c(1e-10, 3, 5), strict = TRUE) # FALSE
all_natural(x = c(1e-10, 3, 5), strict = FALSE) # TRUE
all_natural(x = c(-1e-10, 3, 5), strict = FALSE) # FALSE: wrong sign
all_natural(x = c(3, 5, Inf), strict = FALSE) # FALSE
all_natural(x = "a") # FALSE

# Allowing for small numerical errors is important
x <- sqrt(2)^2
all_natural(x = x) # TRUE
x == 2 # FALSE!
x - 2 # about 4.44e-16

}
\seealso{
\code{progutils::are_equal()} to check for element-wise near-equality of numbers;
\code{\link[=all.equal]{all.equal()}} to check more generally for near-equality; \code{\link[=identical]{identical()}} to
check for exact equality; \link{Comparison} to compare two vectors using binary
operators; \code{\link[=match]{match()}} to compare character vectors. The vignette about type
coercion: \code{vignette("Type_Coercion", package = "checkinput")}.

Other collections of checks on type and length: 
\code{\link{all_characters}()},
\code{\link{all_names}()},
\code{\link{all_nonnegative}()},
\code{\link{are_NA_numeric}()},
\code{\link{is_logical}()},
\code{\link{is_zerolength}()}
}
\concept{collections of checks on type and length}
